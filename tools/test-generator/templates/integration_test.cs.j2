// <auto-generated>
// This file is automatically generated by the test generator.
// DO NOT EDIT THIS FILE MANUALLY - your changes will be overwritten.
// To regenerate this file, run: python generate_integration_tests.py --spec <openapi-spec> --output <output-path>
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using Kinde.Api.Api;
using Kinde.Api.Client;
using Kinde.Api.Model;
using Newtonsoft.Json;
using Xunit;
using Xunit.Abstractions;

namespace {{ namespace }}
{
    /// <summary>
    /// Auto-generated integration tests for all API endpoints
    /// Tests serialization/deserialization round-trips for all converters
    /// </summary>
    [Collection("Integration Tests")]
    public class GeneratedConverterIntegrationTests : BaseIntegrationTest
    {
        private readonly ITestOutputHelper _output;

        public GeneratedConverterIntegrationTests(IntegrationTestFixture fixture, ITestOutputHelper output) 
            : base(fixture)
        {
            _output = output;
        }

{% for api_class, endpoints in endpoints_by_api.items() %}
        #region {{ api_class }} Tests

{% for endpoint in endpoints %}
        [Fact]
        public async Task Test{{ endpoint.method_name }}_Converter()
        {
            SkipIfNotConfigured();
            
            try
            {
{% if endpoint.is_read_only and not endpoint.requires_parameters %}
                // Create API instance with mock HTTP client if in mock mode
                var api = UseMockMode && MockHttpClient != null
                    ? new {{ endpoint.api_class }}(MockHttpClient, ApiConfiguration)
                    : new {{ endpoint.api_class }}(ApiConfiguration);
                
                var result = await api.{{ endpoint.method_name }}Async();
                
                Assert.NotNull(result);
                
                // Show detailed output
                TestOutputHelper.WriteResponseDetails(_output, "{{ endpoint.method_name }}", result);
                
                // Test serialization round-trip
                TestSerializationRoundTrip(result, "{{ endpoint.method_name }}");
{% elif endpoint.is_read_only and endpoint.requires_parameters %}
                // This endpoint requires parameters - skipping automatic test
                // TODO: Add manual test with appropriate parameters
                _output.WriteLine($"Skipping {{ endpoint.method_name }} - requires parameters: {{ endpoint.parameter_names | join(', ') }}");
                return;
{% elif endpoint.request_type %}
                // Write operation - skipping to avoid modifying data
                // TODO: Add manual test with appropriate request object
                _output.WriteLine($"Skipping {{ endpoint.method_name }} - write operation");
                return;
{% else %}
                // Unknown operation type
                _output.WriteLine($"Skipping {{ endpoint.method_name }} - unknown operation type");
                return;
{% endif %}
            }
            catch (Exception ex)
            {
                TestOutputHelper.WriteError(_output, "{{ endpoint.method_name }}", ex);
                throw;
            }
        }

{% endfor %}
        #endregion

{% endfor %}
        #region Helper Methods

        /// <summary>
        /// Tests serialization/deserialization round-trip for a response object
        /// </summary>
        private void TestSerializationRoundTrip<T>(T original, string testName) where T : class
        {
            try
            {
                // Get the standard converters from ApiClient using reflection
                var apiClientType = typeof(Kinde.Api.Client.ApiClient);
                var helperType = apiClientType.Assembly.GetType("Kinde.Api.Client.JsonConverterHelper");
                IList<JsonConverter> converters;
                if (helperType != null)
                {
                    var method = helperType.GetMethod("CreateStandardConverters", 
                        System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Static);
                    if (method != null)
                    {
                        converters = (IList<JsonConverter>)method.Invoke(null, null)!;
                    }
                    else
                    {
                        throw new InvalidOperationException("Could not find CreateStandardConverters method");
                    }
                }
                else
                {
                    throw new InvalidOperationException("Could not find JsonConverterHelper type");
                }
                
                var settings = new JsonSerializerSettings
                {
                    Converters = converters,
                    NullValueHandling = NullValueHandling.Ignore
                };

                // Serialize
                var json = JsonConvert.SerializeObject(original, settings);
                Assert.False(string.IsNullOrEmpty(json), 
                    $"{testName}: Serialization produced empty JSON");

                // Deserialize
                var deserialized = JsonConvert.DeserializeObject<T>(json, settings);
                Assert.NotNull(deserialized);

                // Round-trip comparison
                var originalJson = JsonConvert.SerializeObject(original, settings);
                var deserializedJson = JsonConvert.SerializeObject(deserialized, settings);
                
                Assert.Equal(originalJson, deserializedJson);

                // Use enhanced output helper
                TestOutputHelper.WriteSerializationTest(_output, testName, json.Length, true);
            }
            catch (Exception ex)
            {
                TestOutputHelper.WriteSerializationTest(_output, testName, 0, false);
                _output.WriteLine($"Serialization error: {ex.Message}");
                throw;
            }
        }

        #endregion
    }
}

